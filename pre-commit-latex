#!/usr/bin/python
# -*- coding: utf-8 -*-
"""That is a pre-commit hook to check spurious space in .dtx file
It allows empty line, but not line not finished by %.

MaÃ¯eul Rouquette 2014-....
v 1.0.2
Licence GPl3 https://www.gnu.org/licenses/gpl-3.0.txt
"""

import os
import os.path
import re
import sys

# Setting
to_be_checked = ["dtx","sty","bbx","cbx","lbx"]
commands = {
        "end_line_percent_signe":"Spurious space",
        "cs_cmd":"Don't use \ inside \cs command",
    }
# General code
def change_line_number(line_number,line):
    """Change line number, depending of the current line"""
    if line[0:2] == "@@": # line number
        line_number = re.findall("\+(\d+),?",line)
        line_number = int(line_number[0]) -1
    elif not line[0] == "-" and not line[0:1] == "\\":
        line_number = line_number + 1
    return line_number 

lines_results ={}#global, bad, I have to find an other way. Key = filename_linenumber. content : see check_lines 
def check_lines():
    """ Check all modified lines"""
    diff = os.popen("git diff  --cached")
    line_number = 0
    file_name = ""
    
    for line in diff:
        line_number = change_line_number(line_number,line)
        # what is the file?
        if  "+++ b/" in line:
            file_name = line[6:-1]
            extension = os.path.splitext(file_name)[1][1:]
        elif  "++ /dev/null" in line:
            extension = ""
            file_name = ""
        elif line[0] == "+" and extension in to_be_checked:
            check = check_line(line,line_number,file_name)
            lines_results[file_name+"_"+str(line_number)]={
                 "line_number":line_number, 
                 "content":line,
                 "results":check,
                 "file_name":file_name
                 }
    return lines_results

def check_line(line,line_number,file_name):
    """Check individual added line"""
    results = {}

    for cmd in commands: #Use all commands, keep results
        f = getattr(sys.modules[__name__],"check_"+cmd)
        check = f(line,line_number,file_name)
        if check==False:
            results[cmd] = True
        elif isinstance(check,list):
            results[cmd] = check
    return results
# Tests
def check_cs_cmd(line,line_number,file_name):
    """Check we don't start \cs argument by a \\"""
    return "\cs{\\" not in line

def check_end_line_percent_signe(line,line_number,file_name):
    """"Check line finish by %"""

    line = line.replace("\%","")    # Don't look for protected %  
    
    if line == "+\n":             # Allow empty line
        return True
    
    elif "%" not in line:         # If not % -> problem
        return False

    elif re.search ("\s+%",line): # Spaces before % -> problem 
        return False
    else:
        return True

# Main function
def __main__():
    """Main function: calls the check to bad line, print them if need, and return exit if error"""
    lines_results = check_lines()
    exit = 0 #Set to 1 if we have ONE bad line. 
    seen_file_names=[]
    for line_result in lines_results:
        line= lines_results[line_result]
        if line["results"]!={}: #there is some error 
            exit=1
            if line["file_name"] not in seen_file_names:
                 seen_file_names.append(line["file_name"])
                 print (line["file_name"])
            print ("\x1b[31m\tl."+ str(line["line_number"]) + ": " + line["content"][:-1])
            
            results = line["results"]
            for error in line["results"]:
                if results[error] == True:
                    print ("\t\t " + commands[error])
                else:
                    for e in results[error]:
                        print ("\t\t " + commands[error][e])
            print("\x1b[0m")
    sys.exit(exit)


__main__()
